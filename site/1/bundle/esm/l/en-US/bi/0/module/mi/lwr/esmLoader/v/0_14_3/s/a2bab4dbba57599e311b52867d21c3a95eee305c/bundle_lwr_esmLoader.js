function p(o){let i,t=o[0],n=1;for(;n<o.length;){const e=o[n],s=o[n+1];if(n+=2,(e==="optionalAccess"||e==="optionalCall")&&t==null)return;e==="access"||e==="optionalAccess"?(i=t,t=s(t)):(e==="call"||e==="optionalCall")&&(t=s((...a)=>t.call(i,...a)),i=void 0)}return t}class r{__init(){this.importURICache=new Map}__init2(){this.modifiers=""}constructor(i){r.prototype.__init.call(this),r.prototype.__init2.call(this),this.normalizeMetadata(i),this.mappingEndpoint=p([i,"optionalAccess",t=>t.importMappings])?void 0:p([i,"optionalAccess",t=>t.endpoints,"optionalAccess",t=>t.uris,"access",t=>t.mapping]),p([i,"optionalAccess",t=>t.endpoints,"optionalAccess",t=>t.modifiers])&&(this.modifiers=Object.entries(i.endpoints.modifiers).reduce((t,[n,e])=>t+=`${n}=${e}&`,"?"))}normalizeMetadata(i){if(i&&i.imports)for(const[t,n]of Object.entries(i.imports))t&&n&&(Array.isArray(n)?n:[]).forEach(s=>{this.importURICache.set(s,t)})}async fetchMappings(i){const t=`${this.mappingEndpoint}${encodeURIComponent(i)}${this.modifiers}`,n=await globalThis.fetch(t);if(n.ok){const e=await n.json();this.normalizeMetadata(e)}}async resolve(i){let t=this.importURICache.get(i);return!t&&this.mappingEndpoint&&(await this.fetchMappings(i),t=this.importURICache.get(i)),t}}class d{constructor(i){this.importURICache=i&&i.imports?i:{imports:{}}}legacyResolve(i){return this.importURICache&&this.importURICache.imports&&this.importURICache.imports[i]}}function h(o){let i,t=o[0],n=1;for(;n<o.length;){const e=o[n],s=o[n+1];if(n+=2,(e==="optionalAccess"||e==="optionalCall")&&t==null)return;e==="access"||e==="optionalAccess"?(i=t,t=s(t)):(e==="call"||e==="optionalCall")&&(t=s((...a)=>t.call(i,...a)),i=void 0)}return t}let u,l,c;function f(o){u=o;const{imports:i,index:t,importMappings:n,endpoints:e}=o;l=new r({imports:i,index:t,endpoints:e,importMappings:n}),c=new d(n)}async function m(o,i){return import(await C(o,i))}async function C(o,i){if(o.includes("://")||o.startsWith("/"))return o;if(!l||!c)throw new Error("The ESM Loader was not initialized");if(l){const e=await l.resolve(o);if(e)return e}if(c){const e=c.legacyResolve(o);if(e)return e}const{endpoints:t}=u;if(!h([t,"optionalAccess",e=>e.uris,"optionalAccess",e=>e.module]))throw new Error(`Unable to resolve the URL for "${o}"`);let n=t.uris.module+encodeURIComponent(o);return i&&(n+=`?importer=${encodeURIComponent(i)}`),t.modifiers&&(n+=Object.entries(t.modifiers).reduce((e,[s,a])=>e+=`${s}=${a}&`,i?"&":"?")),n}export{f as init,m as load};
